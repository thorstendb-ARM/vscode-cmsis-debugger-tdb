Expression strings, line by line:
36
0
4
8
12
16
20
24
28
32
80
1
2
3
-1
0x13
0x23
0x33
0x43
0x53
0x63
0x73
0x83
0x93
0x00
0x01
0x02
0x04
8+1
8+2
8+3
8+4
8+5
8+6
8+7
16+1
16+2
16+3
16+4
16+5
16+6
16+7
24+1
24+2
24+3
24+4
24+5
24+6
24+7
32+1
32+2
32+3
32+4
32+5
32+6
32+7
40
40+1
40+2
40+3
40+4
40+5
40+6
40+7
48
48+1
48+2
48+3
48+4
48+5
48+6
48+7
56
33
34
35
44
52
60
64
68
69
72
76
0x08
14
12+0
12+4
12+8
12+12
12+16
12+20
164
5
9
10
11
28+0
28+1
28+2
28+3
28+4
28+8
84
86
88
90
92
96
100
104
108
112
116
120
124
128
132
136
140
144
148
152
156
160
18
-2
-3
-4
-5
-6
-7
-8
-9
-10
-11
-12
-13
-14
-15
-16
-17
-18
-19
-20
-21
-22
-23
-24
0x03
13
15
17
19
21
22
23
25
26
27
29
30
31
37
38
39
41
42
43
45
46
47
49
50
51
53
54
55
6
v8m_ns = __Symbol_exists("TZ_InitContextSystem_S");
os_Config.stack_check = (os_Config.flags >> 1) & 1;
os_Config.stack_wmark = (os_Config.flags >> 2) & 1;
os_Config.safety_feat = (os_Config.flags >> 3) & 1;
os_Config.safety_class = (os_Config.flags >> 4) & 1;
os_Config.exec_zone = (os_Config.flags >> 5) & 1;
os_Config.watchdog = (os_Config.flags >> 6) & 1;
os_Config.obj_check = (os_Config.flags >> 7) & 1;
os_Config.svc_check = (os_Config.flags >> 8) & 1;
RTX_En = 1;
V_Major = os_Info.version / 10000000;
V_Minor = (os_Info.version / 10000) % 1000;
V_Patch = os_Info.version % 10000;
StaticMp_En = 1;
TCB_Rd = cb_Sections.thread_cb_end - cb_Sections.thread_cb_start;
CCB_Rd = cb_Sections.timer_cb_end - cb_Sections.timer_cb_start;
ECB_Rd = cb_Sections.evflags_cb_end - cb_Sections.evflags_cb_start;
MCB_Rd = cb_Sections.mutex_cb_end - cb_Sections.mutex_cb_start;
SCB_Rd = cb_Sections.semaphore_cb_end - cb_Sections.semaphore_cb_start;
PCB_Rd = cb_Sections.mempool_cb_end - cb_Sections.mempool_cb_start;
QCB_Rd = cb_Sections.msgqueue_cb_end - cb_Sections.msgqueue_cb_start;
TCB_Rd /= 80;
CCB_Rd /= 32;
ECB_Rd /= 16;
MCB_Rd /= 28;
SCB_Rd /= 16;
PCB_Rd /= 36;
QCB_Rd /= 52;
mem_head_stack.max_used = mem_list_stack[mem_list_stack._count-1].len;
mem_head_mp_data.max_used = mem_list_mp_data[mem_list_mp_data._count-1].len;
mem_head_mq_data.max_used = mem_list_mq_data[mem_list_mq_data._count-1].len;
mem_head_com.max_used = mem_list_com[mem_list_com._count-1].len;
k = 0;
k = 0; j = 0;
MUC_Thread_En = 1;
MUC_Timer_En = 1;
MUC_EventFlags_En = 1;
MUC_Mutex_En = 1;
MUC_Semaphore_En = 1;
MUC_MemPool_En = 1;
MUC_MsgQueue_En = 1;
MUC_En = MUC_Thread_En | MUC_Timer_En | MUC_EventFlags_En | MUC_Mutex_En | MUC_Semaphore_En | MUC_MemPool_En | MUC_MsgQueue_En;
osRtxInfo
osRtxConfig
((os_Info.version / 10000000) == 5) && (os_Info.kernel_state > 0) && (os_Info.kernel_state < 5)
RTX_En
RTX_En && (os_Config.mpi_thread || os_Config.mpi_timer || os_Config.mpi_event_flags || os_Config.mpi_mutex || os_Config.mpi_semaphore || os_Config.mpi_memory_pool || os_Config.mpi_message_queue)
os_Config.isr_queue_data
os_Config.isr_queue_max
__Symbol_exists ("os_cb_sections")
os_cb_sections
RTX_En && __Symbol_exists ("os_cb_sections")
TCB_Rd
CCB_Rd
ECB_Rd
MCB_Rd
SCB_Rd
PCB_Rd
QCB_Rd
cb_Sections.thread_cb_start
cb_Sections.timer_cb_start
cb_Sections.evflags_cb_start
cb_Sections.mutex_cb_start
cb_Sections.mempool_cb_start
cb_Sections.semaphore_cb_start
cb_Sections.msgqueue_cb_start
os_Config.mpi_stack
os_Config.mpi_thread
os_Config.mpi_timer
os_Config.mpi_event_flags
os_Config.mpi_mutex
os_Config.mpi_semaphore
os_Config.mpi_memory_pool
os_Config.mpi_message_queue
os_Info.thread_idle
RTX_En && (TCB_Rd == 0) && os_Info.thread_idle
os_Info.timer_thread
RTX_En && (TCB_Rd == 0) && os_Info.timer_thread
os_Info.mpi_thread
RTX_En && (TCB_Rd == 0) && os_Info.mpi_thread
mp_thread.block_base
mp_thread.max_blocks
os_Info.mpi_timer
RTX_En && (CCB_Rd == 0) && os_Info.mpi_timer
mp_timer.block_base
mp_timer.max_blocks
os_Info.mpi_event_flags
RTX_En && (ECB_Rd == 0) && os_Info.mpi_event_flags
mp_events.block_base
mp_events.max_blocks
os_Info.mpi_mutex
RTX_En && (MCB_Rd == 0) && os_Info.mpi_mutex
mp_mutex.block_base
mp_mutex.max_blocks
os_Info.mpi_semaphore
RTX_En && (SCB_Rd == 0) && os_Info.mpi_semaphore
mp_semaphore.block_base
mp_semaphore.max_blocks
os_Info.mpi_memory_pool
RTX_En && (PCB_Rd == 0) && os_Info.mpi_memory_pool
mp_mpool.block_base
mp_mpool.max_blocks
os_Info.mpi_message_queue
RTX_En && (QCB_Rd == 0) && os_Info.mpi_message_queue
mp_mqueue.block_base
mp_mqueue.max_blocks
os_Config.mem_stack_addr
RTX_En && os_Config.mem_stack_addr
os_Config.mem_stack_addr + 8
next
os_Config.mem_mp_data_addr
RTX_En && os_Config.mem_mp_data_addr
os_Config.mem_mp_data_addr + 8
os_Config.mem_mq_data_addr
RTX_En && os_Config.mem_mq_data_addr
os_Config.mem_mq_data_addr + 8
os_Config.mem_common_addr
RTX_En && os_Config.mem_common_addr
os_Config.mem_common_addr + 8
mem_list_com._count > 1
mem_list_com._count-1
addr = mem_list_com[i]._addr;
addr += 8;
addr
(mem_list_com[i].len & 1) && (mem_list_com[i].id == 0xF1)
(mem_list_com[i].len & 1) && (mem_list_com[i].id == 0xF2)
(mem_list_com[i].len & 1) && (mem_list_com[i].id == 0xF3)
(mem_list_com[i].len & 1) && (mem_list_com[i].id == 0xF5)
(mem_list_com[i].len & 1) && (mem_list_com[i].id == 0xF6)
(mem_list_com[i].len & 1) && (mem_list_com[i].id == 0xF7)
(mem_list_com[i].len & 1) && (mem_list_com[i].id == 0xFA)
os_Info.thread_wdog_list
RTX_En && os_Config.watchdog && os_Info.thread_wdog_list
wdog_next
TCB._count
TCB[i].cb_valid = (TCB[i].id == 0xF1) && (TCB[i].state != 0) && (TCB[i].sp != 0);
TCB[i].sp_valid = 1;
os_Info.robin_tick = TCB[i].delay;
ipsr = __GetRegVal("XPSR") & 0x01FF;
psp = (v8m_ns == 0) ? (__GetRegVal("PSP")) : (__GetRegVal("PSP_NS"));
psp = (psp == 0) ? (TCB[i].sp) : (psp);
sp = ((ipsr != 0) && (ipsr < 16)) ? (TCB[i].sp) : (psp);
TCB[i].sp_valid = ((ipsr != 0) && (ipsr < 16)) ? (0) : (1);
TCB[i].sp_valid = 0;
sp = TCB[i].sp;
TCB[i].stack_cur = sp;
TCB[i].stack_curb = TCB[i].stack_mem + TCB[i].stack_size;
TCB[i].stack_curb -= sp;
TCB[i].stack_curp = TCB[i].stack_curb;
TCB[i].stack_curp *= 100;
TCB[i].stack_curp /= TCB[i].stack_size;
TCB[i].stack_over = (sp <= TCB[i].stack_mem) ? 1 : 0;
TCB[i].stack_val = __CalcMemUsed (TCB[i].stack_mem, sp - TCB[i].stack_mem, 0xCCCCCCCC, 0xE25A2EA5);
TCB[i].stack_over = TCB[i].stack_val >> 31;
TCB[i].stack_maxb = (TCB[i].stack_mem + TCB[i].stack_size) - sp;
TCB[i].stack_maxb += TCB[i].stack_val & 0xFFFFF;
TCB[i].stack_maxp = (TCB[i].stack_maxb * 100)/ TCB[i].stack_size;
TCB[i].stack_maxb = TCB[i].stack_size;
TCB[i].stack_maxp = 100;
TCB[i].stack_maxb = TCB[i].stack_curb;
TCB[i].stack_maxp = TCB[i].stack_curp;
TCB[i].ex_delay = TCB[i].delay;
TCB[i].wd_state = k;
(TCB[i].state == 2) && os_Config.robin_timeout
(TCB[i].state == 2) && (__Running == 0)
(TCB[i].state == 2) && (__Running == 1)
TCB[i].state != 2
TCB[i].sp != 0
(os_Config.stack_wmark != 0) && (TCB[i].sp != 0) && (TCB[i].stack_over == 0) && (TCB[i].stack_size < 65536)
(TCB[i].sp != 0) && (TCB[i].stack_over != 0)
(TCB[i].sp != 0) && (TCB[i].stack_curb >= TCB[i].stack_maxb)
TCB[i].delay_prev
TCB[i].delay != -1
delay_prev
TDL._count
TCB[i].ex_delay += TDL[j].delay;
os_Config.watchdog
WDL._count
TCB[i].wd_tick += WDL[j].wdog_tick;
k = 1;
k == 0
TCB[i]._addr == WDL[j]._addr
os_Config.safety_feat
CCB._count
CCB[i].cb_valid = (CCB[i].id == 0xF2) && (CCB[i].state != 0);
CCB[i].ex_tick = CCB[i].tick;
CCB[i].prev
prev
TEL._count
CCB[i].ex_tick += TEL[j].tick;
ECB._count
ECB[i].cb_valid = (ECB[i].id == 0xF3);
ECB[i].wl_idx = k;
ECB[i].wl_cnt = 0;
ECB[i].wl_cnt = (EWL._count - k);
k = EWL._count;
ECB[i].thread_list
thread_next
MCB._count
MCB[i].cb_valid = (MCB[i].id == 0xF5);
MCB[i].wl_idx = k;
MCB[i].wl_cnt = 0;
MCB[i].wl_cnt = (MWL._count - k);
k = MWL._count;
MCB[i].thread_list
SCB._count
SCB[i].cb_valid = (SCB[i].id == 0xF6);
SCB[i].wl_idx = k;
SCB[i].wl_cnt = 0;
SCB[i].wl_cnt = (SWL._count - k);
k = SWL._count;
SCB[i].thread_list
PCB._count
PCB[i].cb_valid = (PCB[i].id == 0xF7);
PCB[i].wl_idx = k;
PCB[i].wl_cnt = 0;
PCB[i].wl_cnt = (PWL._count - k);
k = PWL._count;
PCB[i].thread_list
QCB._count
QCB[i].cb_valid = (QCB[i].id == 0xFA);
QCB[i].wl_idx = k;
QCB[i].wl_cnt = 0;
QCB[i].wl_cnt = (QWL._count - k);
k = QWL._count;
QCB[i].ml_idx = j;
QCB[i].ml_cnt = (QML._count - j)
j = QML._count;
QCB[i].thread_list
QCB[i].msg_first
QML._count
QML[i].addr = QML[i]._addr;
QML[i].addr += 12;
__Symbol_exists ("osRtxThreadMemUsage")
__Symbol_exists ("osRtxTimerMemUsage")
__Symbol_exists ("osRtxEventFlagsMemUsage")
__Symbol_exists ("osRtxMutexMemUsage")
__Symbol_exists ("osRtxSemaphoreMemUsage")
__Symbol_exists ("osRtxMemoryPoolMemUsage")
__Symbol_exists ("osRtxMessageQueueMemUsage")
MUC_Thread_En
osRtxThreadMemUsage
MUC_Timer_En
osRtxTimerMemUsage
MUC_EventFlags_En
osRtxEventFlagsMemUsage
MUC_Mutex_En
osRtxMutexMemUsage
MUC_Semaphore_En
osRtxSemaphoreMemUsage
MUC_MemPool_En
osRtxMemoryPoolMemUsage
MUC_MsgQueue_En
osRtxMessageQueueMemUsage
TCB_En += TCB[i].cb_valid;
TCB[i].out_type = 0;
TCB[i].out_type = 1;
TCB[i].out_type = 2;
TCB[i].out_type = 3;
TCB[i].out_type = 4;
TCB[i].out_type += 4;
TCB[i].cb_valid == 0
TCB[i].cb_valid && (TCB[i].name == 0) && (os_Config.stack_wmark == 0)
TCB[i].cb_valid && (TCB[i].name == 0) && (os_Config.stack_wmark != 0)
TCB[i].cb_valid && (TCB[i].name != 0) && (os_Config.stack_wmark == 0)
TCB[i].cb_valid && (TCB[i].name != 0) && (os_Config.stack_wmark != 0)
TCB[i].sp_valid == 0
CCB_En += CCB[i].cb_valid;
SCB_En += SCB[i].cb_valid;
MCB_En += MCB[i].cb_valid;
ECB_En += ECB[i].cb_valid;
PCB_En += PCB[i].cb_valid;
QCB_En += QCB[i].cb_valid;
RTX V%d[V_Major].%d[V_Minor].%d[V_Patch]
RTX_En != 0
osKernelInactive
RTX_En == 0
%E[os_Info.kernel_state]
osThreadPrivileged: %t[(os_Info.kernel_protect & 1) ? "Disabled" : "Enabled"]
(os_Config.safety_feat == 1) && (os_Config.safety_class == 0) && (RTX_En != 0)
osThreadPrivileged: %t[(os_Info.kernel_protect & 1) ? "Disabled" : "Enabled"], osSafetyClass(%d[os_Info.kernel_protect/16])
(os_Config.safety_feat == 1) && (os_Config.safety_class == 1) && (RTX_En != 0)
%d[os_Info.kernel_tick]
%d[os_Config.tick_freq]
Disabled
(os_Config.robin_timeout == 0) && (RTX_En != 0)
%d[os_Info.robin_tick]
(os_Config.robin_timeout > 0) && (RTX_En != 0)
%d[os_Config.robin_timeout]
Not used
(os_Config.mem_common_size == 0) && (RTX_En != 0)
Base: %x[mem_head_com._addr], Size: %d[mem_head_com.size], Used: %d[mem_head_com.used], Max used: %d[mem_head_com.max_used]
(os_Config.mem_common_size != 0) && (RTX_En != 0)
%t[os_Config.stack_check ? "Enabled" : "Disabled"]
%t[os_Config.stack_wmark ? "Enabled" : "Disabled"]
%d[os_Config.thread_stack_size]
Size: %d[os_Info.isr_queue_max], Used: %d[os_Info.isr_queue_cnt]
os_Info.isr_queue_cnt
%x[ISR_FIFO[i]]
data[%d[i]]
StaticMp_En
Used: %d[cfg_mp_thread.used_blocks], Max: %d[cfg_mp_thread.max_blocks]
Base: %x[cfg_mp_thread.block_base], Size: %d[cfg_mp_thread.block_lim - cfg_mp_thread.block_base], Used: %d[cfg_mp_thread.used_blocks * cfg_mp_thread.block_size]
Base: %x[cfg_mp_stack.block_base], Size: %d[cfg_mp_stack.block_lim - cfg_mp_stack.block_base], Used: %d[cfg_mp_stack.used_blocks * cfg_mp_stack.block_size]
Base: %x[mem_head_stack._addr], Size: %d[mem_head_stack.size], Used: %d[mem_head_stack.used], Max used: %d[mem_head_stack.max_used]
os_Config.mem_stack_size
Used: %d[cfg_mp_timer.used_blocks], Max: %d[cfg_mp_timer.max_blocks]
Base: %x[cfg_mp_timer.block_base], Size: %d[cfg_mp_timer.block_lim - cfg_mp_timer.block_base], Used: %d[cfg_mp_timer.used_blocks * cfg_mp_timer.block_size]
Used: %d[cfg_mp_events.used_blocks], Max: %d[cfg_mp_events.max_blocks]
Base: %x[cfg_mp_events.block_base], Size: %d[cfg_mp_events.block_lim - cfg_mp_events.block_base], Used: %d[cfg_mp_events.used_blocks * cfg_mp_events.block_size]
Used: %d[cfg_mp_mutex.used_blocks], Max: %d[cfg_mp_mutex.max_blocks]
Base: %x[cfg_mp_mutex.block_base], Size: %d[cfg_mp_mutex.block_lim - cfg_mp_mutex.block_base], Used: %d[cfg_mp_mutex.used_blocks * cfg_mp_mutex.block_size]
Used: %d[cfg_mp_semaphore.used_blocks], Max: %d[cfg_mp_semaphore.max_blocks]
Base: %x[cfg_mp_semaphore.block_base], Size: %d[cfg_mp_semaphore.block_lim - cfg_mp_semaphore.block_base], Used: %d[cfg_mp_semaphore.used_blocks * cfg_mp_semaphore.block_size]
Used: %d[cfg_mp_mpool.used_blocks], Max: %d[cfg_mp_mpool.max_blocks]
Base: %x[cfg_mp_mpool.block_base], Size: %d[cfg_mp_mpool.block_lim - cfg_mp_mpool.block_base], Used: %d[cfg_mp_mpool.used_blocks * cfg_mp_mpool.block_size]
Base: %x[mem_head_mp_data._addr], Size: %d[mem_head_mp_data.size], Used: %d[mem_head_mp_data.used], Max used: %d[mem_head_mp_data.max_used]
os_Config.mem_mp_data_size
Used: %d[cfg_mp_mqueue.used_blocks], Max: %d[cfg_mp_mqueue.max_blocks]
Base: %x[cfg_mp_mqueue.block_base], Size: %d[cfg_mp_mqueue.block_lim - cfg_mp_mqueue.block_base], Used: %d[cfg_mp_mqueue.used_blocks * cfg_mp_mqueue.block_size]
Base: %x[mem_head_mq_data._addr], Size: %d[mem_head_mq_data.size], Used: %d[mem_head_mq_data.used], Max used: %d[mem_head_mq_data.max_used]
os_Config.mem_mq_data_size
(MUC_En != 0) && (RTX_En != 0)
Alloc: %d[MUC_Thread.cnt_alloc], Free: %d[MUC_Thread.cnt_free], Max used: %d[MUC_Thread.max_used]
Alloc: %d[MUC_Timer.cnt_alloc], Free: %d[MUC_Timer.cnt_free], Max used: %d[MUC_Timer.max_used]
Alloc: %d[MUC_EventFlags.cnt_alloc], Free: %d[MUC_EventFlags.cnt_free], Max used: %d[MUC_EventFlags.max_used]
Alloc: %d[MUC_Mutex.cnt_alloc], Free: %d[MUC_Mutex.cnt_free], Max used: %d[MUC_Mutex.max_used]
Alloc: %d[MUC_Semaphore.cnt_alloc], Free: %d[MUC_Semaphore.cnt_free], Max used: %d[MUC_Semaphore.max_used]
Alloc: %d[MUC_MemPool.cnt_alloc], Free: %d[MUC_MemPool.cnt_free], Max used: %d[MUC_MemPool.max_used]
Alloc: %d[MUC_MsgQueue.cnt_alloc], Free: %d[MUC_MsgQueue.cnt_free], Max used: %d[MUC_MsgQueue.max_used]
TCB_En
%E[TCB[i].state & 0x07], %E[TCB[i].priority], Stack Used: %d[TCB[i].stack_curp]%%
TCB[i].out_type == 1
id: %x[TCB[i]._addr] "%S[TCB[i].thread_addr]"
TCB[i].stack_over != 0
%E[TCB[i].state & 0x07], %E[TCB[i].priority], Stack Used: %d[TCB[i].stack_curp]%%, Max: %d[TCB[i].stack_maxp]%%
TCB[i].out_type == 2
TCB[i].out_type == 3
id: %x[TCB[i]._addr] %N[TCB[i].name]
TCB[i].out_type == 4
%E[TCB[i].state & 0x07], %E[TCB[i].priority], Stack Used: unknown
TCB[i].out_type == 5
%E[TCB[i].state & 0x07], %E[TCB[i].priority], Stack Used: unknown, Max: %d[TCB[i].stack_maxp]%%
TCB[i].out_type == 6
TCB[i].out_type == 7
TCB[i].out_type == 8
%E[TCB[i].state & 0x07]
%E[TCB[i].priority]
%E[TCB[i].attr & 0x01], %E[TCB[i].attr & 0x06]
(os_Config.exec_zone == 0) && (os_Config.safety_class == 0)
%E[TCB[i].attr & 0x01], %E[TCB[i].attr & 0x06], osSafetyClass(%d[TCB[i].attr/16])
(os_Config.exec_zone == 0) && (os_Config.safety_class == 1)
%E[TCB[i].attr & 0x01], %E[TCB[i].attr & 0x06], osThreadZone(%d[TCB[i].zone])
(os_Config.exec_zone == 1) && (os_Config.safety_class == 0)
%E[TCB[i].attr & 0x01], %E[TCB[i].attr & 0x06], osSafetyClass(%d[TCB[i].attr/16]), osThreadZone(%d[TCB[i].zone])
(os_Config.exec_zone == 1) && (os_Config.safety_class == 1)
%E[TCB[i].state], Timeout: %d[TCB[i].ex_delay]
((TCB[i].state & 0x07) == 3) && (TCB[i].ex_delay != -1)
%E[TCB[i].state], Timeout: osWaitForever
((TCB[i].state & 0x07) == 3) && (TCB[i].ex_delay == -1)
TCB[i].state == 0x23
id: %x[TCB[i].thread_join]
TCB[i].state == 0x33
id: %x[TCB[i].thread_prev]
TCB[i].state == 0x43
TCB[i].thread_prev == ECB[n]._addr
id: %x[ECB[n]._addr] %N[ECB[n].name]
TCB[i].state == 0x53
TCB[i].thread_prev == MCB[n]._addr
id: %x[MCB[n]._addr] %N[MCB[n].name]
TCB[i].state == 0x63
TCB[i].thread_prev == SCB[n]._addr
id: %x[SCB[n]._addr] %N[SCB[n].name]
TCB[i].state == 0x73
TCB[i].thread_prev == PCB[n]._addr
id: %x[PCB[n]._addr] %N[PCB[n].name]
(TCB[i].state == 0x83) || (TCB[i].state == 0x84)
TCB[i].thread_prev == QCB[n]._addr
id: %x[QCB[n]._addr] %N[QCB[n].name]
Used: unknown
(TCB[i].sp_valid == 0) && (os_Config.stack_wmark == 0)
Used: unknown, Max: %d[TCB[i].stack_maxp]%% [%d[TCB[i].stack_maxb]]
(TCB[i].sp_valid == 0) && (os_Config.stack_wmark != 0)
Used: %d[TCB[i].stack_curp]%% [%d[TCB[i].stack_curb]]
(TCB[i].sp_valid == 1) && (os_Config.stack_wmark == 0)
Used: %d[TCB[i].stack_curp]%% [%d[TCB[i].stack_curb]], Max: %d[TCB[i].stack_maxp]%% [%d[TCB[i].stack_maxb]]
(TCB[i].sp_valid == 1) && (os_Config.stack_wmark != 0)
unknown
%d[TCB[i].stack_curb]
TCB[i].sp_valid == 1
%d[TCB[i].stack_maxb]
os_Config.stack_wmark != 0
%x[TCB[i].stack_mem + TCB[i].stack_size]
%x[TCB[i].stack_cur]
%x[TCB[i].stack_mem]
%d[TCB[i].stack_size]
Overrun detected
%x[TCB[i].thread_flags]
Inactive
(os_Config.watchdog != 0) && (TCB[i].wd_state == 0)
Running, Timeout: %d[TCB[i].wd_tick]
(os_Config.watchdog != 0) && (TCB[i].wd_state == 1)
%x[TCB[i].wait_flags], %E[TCB[i].flags_options & 1]
(TCB[i].wait_flags != 0) && ((TCB[i].flags_options & 2) == 0)
%x[TCB[i].wait_flags], %E[TCB[i].flags_options & 1], osFlagsNoClear
(TCB[i].wait_flags != 0) && ((TCB[i].flags_options & 2) != 0)
%d[TCB[i].tz_memory]
TCB[i].tz_memory
CCB_En
%E[CCB[i].state], Tick: %d[CCB[i].ex_tick]
CCB[i].cb_valid
id: %x[CCB[i]._addr] %N[CCB[i].name]
%E[CCB[i].state]
%E[CCB[i].attr & 0x01]
osSafetyClass(%d[CCB[i].attr/16])
os_Config.safety_class == 1
%d[CCB[i].ex_tick]
%d[CCB[i].load]
Func: %S[CCB[i].finfo_fp], Arg: %x[CCB[i].finfo_arg]
SCB_En
Tokens: %d[SCB[i].tokens], Max: %d[SCB[i].max_tokens]
SCB[i].cb_valid
id: %x[SCB[i]._addr] %N[SCB[i].name]
osSafetyClass(%d[SCB[i].attr/16])
%d[SCB[i].tokens]
%d[SCB[i].max_tokens]
SCB[i].wl_cnt
Threads waiting (%d[SCB[i].wl_cnt])
SCB[i].wl_idx
SCB[i].wl_idx + SCB[i].wl_cnt
Timeout: %d[TCB[k].ex_delay]
(SWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay != -1)
id: %x[TCB[k]._addr] %N[TCB[k].name]
Timeout: osWaitForever
(SWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay == -1)
MCB_En
Lock counter: %d[MCB[i].lock]
MCB[i].cb_valid
id: %x[MCB[i]._addr] %N[MCB[i].name]
%x[MCB[i].lock]
osSafetyClass(%d[MCB[i].attr/16])
%t[(MCB[i].attr & 0x01) ? "True" : "False"]
%t[(MCB[i].attr & 0x02) ? "True" : "False"]
%t[(MCB[i].attr & 0x08) ? "True" : "False"]
MCB[i].lock
id: %x[TCB[n]._addr] %N[TCB[n].name]
MCB[i].owner_thread == TCB[n]._addr
MCB[i].wl_cnt
Threads waiting (%d[MCB[i].wl_cnt])
MCB[i].wl_idx
MCB[i].wl_idx + MCB[i].wl_cnt
(MWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay != -1)
(MWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay == -1)
ECB_En
Flags: %x[ECB[i].event_flags]
ECB[i].cb_valid
id: %x[ECB[i]._addr] %N[ECB[i].name]
osSafetyClass(%d[ECB[i].attr/16])
ECB[i].wl_cnt
Threads waiting (%d[ECB[i].wl_cnt])
ECB[i].wl_idx
ECB[i].wl_idx + ECB[i].wl_cnt
(EWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay != -1)
(EWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay == -1)
PCB_En
Used: %d[PCB[i].used_blocks], Max: %d[PCB[i].max_blocks]
PCB[i].cb_valid
id: %x[PCB[i]._addr] %N[PCB[i].name]
osSafetyClass(%d[PCB[i].attr/16])
%d[PCB[i].used_blocks]
%d[PCB[i].max_blocks]
%d[PCB[i].block_size]
%x[PCB[i].block_base]
%d[PCB[i].block_lim - PCB[i].block_base]
PCB[i].wl_cnt
Threads waiting (%d[PCB[i].wl_cnt])
PCB[i].wl_idx
PCB[i].wl_idx + PCB[i].wl_cnt
(PWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay != -1)
(PWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay == -1)
QCB_En
Messages: %d[QCB[i].msg_count], Max: %d[QCB[i].max_blocks]
QCB[i].cb_valid
id: %x[QCB[i]._addr] %N[QCB[i].name]
osSafetyClass(%d[QCB[i].attr/16])
%d[QCB[i].ml_cnt]
%d[QCB[i].max_blocks]
%d[QCB[i].msg_size]
QCB[i].wl_cnt
Threads waiting (%d[QCB[i].wl_cnt])
QCB[i].wl_idx
QCB[i].wl_idx + QCB[i].wl_cnt
(QWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay != -1)
(QWL[j].stack_mem == TCB[k].stack_mem) && (TCB[k].ex_delay == -1)
QCB[i].ml_cnt
Queue (%d[QCB[i].ml_cnt])
Address: %x[QML[j + QCB[i].ml_idx].addr], Priority: %d[QML[j + QCB[i].ml_idx].priority]
Queue[%d[j]]
0xF0
0xF1
0xF2
0xF3
0xF4
0xF5
0xF6
0xF7
0xF8
0xF9
0xFA
mem=%x[val1], size=%d[val2], result=%d[val3]
0xF000 + 0x00
mem=%x[val1], size=%d[val2], type=%d[val3], block=%x[val4]
0xF000 + 0x01
mem=%x[val1], block=%x[val2], result=%d[val3]
0xF000 + 0x02
mp_info=%x[val1], block_count=%d[val2], block_size=%d[val3], block_mem=%x[val4]
0xF000 + 0x03
mp_info=%x[val1], block=%x[val2]
0xF000 + 0x04
mp_info=%x[val1], block=%x[val2], status=%E[val3, rtx_t:status]
0xF000 + 0x05
status=%E[val1, rtx_t:status]
0xF100 + 0x00
0xF100 + 0x01
0xF100 + 0x02
version=%x[val1], id_buf=%x[val2], id_size=%d[val3]
0xF100 + 0x03
version_api=%d[val1/10000000].%d[(val1/10000)%1000].%d[val1%10000], version_kernel=%d[val2/10000000].%d[(val2/10000)%1000].%d[val2%10000]
0xF100 + 0x04
id=%t[val1]
0xF100 + 0x05
state=%E[val1, rtx_kernel_state:id]
0xF100 + 0x06
0xF100 + 0x07
0xF100 + 0x08
0xF100 + 0x09
lock=%d[val1]
0xF100 + 0x0A
0xF100 + 0x0B
0xF100 + 0x0C
0xF100 + 0x0D
0xF100 + 0x0E
0xF100 + 0x0F
sleep_ticks=%d[val1]
0xF100 + 0x10
0xF100 + 0x11
0xF100 + 0x12
safety_class=%d[val1]
0xF100 + 0x17
0xF100 + 0x18
count=%d[val1]
0xF100 + 0x13
freq=%d[val1]
0xF100 + 0x14
0xF100 + 0x15
0xF100 + 0x16
code=%E[val1, rtx_error:id], object_id=%x[val2]
0xF100 + 0x19
safety_class=%d[val1], mode=%x[val2]
0xF100 + 0x1A
thread_id=%x[val1], status=%E[val2, rtx_t:status]
0xF200 + 0x00
func=%S[val1], argument=%x[val2], attr=%x[val3]
0xF200 + 0x01
thread_id=%x[val1]
0xF200 + 0x03
%S[val2]
0xF200 + 0x2C
%N[val2]
thread_id=%x[val1], name=%N[val2]
0xF200 + 0x04
thread_id=%x[val1], safety_class=%d[val2]
0xF200 + 0x30
thread_id=%x[val1], zone=%d[val2]
0xF200 + 0x31
0xF200 + 0x06
thread_id=%x[val1], state=%E[val2, rtx_th_state:id]
0xF200 + 0x07
thread_id=%x[val1], stack_size=%d[val2]
0xF200 + 0x08
thread_id=%x[val1], stack_space=%d[val2]
0xF200 + 0x09
thread_id=%x[val1], priority=%E[val2, rtx_th_priority:id]
0xF200 + 0x0A
0xF200 + 0x2D
0xF200 + 0x0B
0xF200 + 0x0C
0xF200 + 0x0D
0xF200 + 0x0E
0xF200 + 0x0F
0xF200 + 0x10
0xF200 + 0x11
0xF200 + 0x12
0xF200 + 0x13
0xF200 + 0x14
0xF200 + 0x15
thread_id=%x[val1], timeout=%d[val2]
0xF200 + 0x16
thread_id=%x[val1], ret_val=%E[val2, rtx_t:status]
0xF200 + 0x17
0xF200 + 0x18
0xF200 + 0x19
0xF200 + 0x1A
0xF200 + 0x1B
0xF200 + 0x1C
ticks=%d[val1]
0xF200 + 0x2E
0xF200 + 0x2F
0xF200 + 0x32
0xF200 + 0x33
0xF200 + 0x1D
thread_array=%x[val1], array_items=%d[val2], count=%d[val3]
0xF200 + 0x1E
0xF200 + 0x34
0xF200 + 0x35
zone=%d[val1]
0xF200 + 0x36
0xF200 + 0x37
0xF400 + 0x00
thread_id=%x[val1], flags=%x[val2]
0xF400 + 0x01
thread_id=%x[val1], thread_flags=%x[val2]
0xF400 + 0x02
flags=%x[val1]
0xF400 + 0x03
thread_flags=%x[val1]
0xF400 + 0x04
0xF400 + 0x05
flags=%x[val1], options=%x[val2], timeout=%d[val3]
0xF400 + 0x06
0xF400 + 0x07
0xF400 + 0x08
flags=%x[val1], options=%x[val2], thread_flags=%x[val3], thread_id=%x[val4]
0xF400 + 0x09
flags=%x[val1], options=%x[val2]
0xF400 + 0x0A
0xF300 + 0x00
0xF300 + 0x01
0xF300 + 0x02
0xF300 + 0x03
0xF300 + 0x04
0xF300 + 0x05
timer_id=%x[val1], status=%E[val2, rtx_t:status]
0xF600 + 0x00
func=%S[val1], argument=%x[val2]
0xF600 + 0x01
func=%S[val1], type=%E[val2, rtx_timer_type:id], argument=%x[val3], attr=%x[val4]
0xF600 + 0x02
timer_id=%x[val1]
0xF600 + 0x04
timer_id=%x[val1], name=%N[val2]
0xF600 + 0x05
timer_id=%x[val1], ticks=%d[val2]
0xF600 + 0x07
0xF600 + 0x08
0xF600 + 0x09
0xF600 + 0x0A
timer_id=%x[val1], running=%d[val2]
0xF600 + 0x0B
0xF600 + 0x0C
0xF600 + 0x0D
ef_id=%x[val1], status=%E[val2, rtx_t:status]
0xF500 + 0x00
attr=%x[val1]
0xF500 + 0x01
ef_id=%x[val1]
0xF500 + 0x03
ef_id=%x[val1], name=%N[val2]
0xF500 + 0x04
ef_id=%x[val1], flags=%x[val2]
0xF500 + 0x06
ef_id=%x[val1], event_flags=%x[val2]
0xF500 + 0x07
0xF500 + 0x08
0xF500 + 0x09
0xF500 + 0x0A
ef_id=%x[val1], flags=%x[val2], options=%x[val3], timeout=%d[val4]
0xF500 + 0x0B
0xF500 + 0x0C
0xF500 + 0x0D
ef_id=%x[val1], flags=%x[val2], options=%x[val3], event_flags=%x[val4]
0xF500 + 0x0E
ef_id=%x[val1], flags=%x[val2], options=%x[val3]
0xF500 + 0x0F
0xF500 + 0x10
0xF500 + 0x11
mutex_id=%x[val1], status=%E[val2, rtx_t:status]
0xF700 + 0x00
0xF700 + 0x01
mutex_id=%x[val1]
0xF700 + 0x03
mutex_id=%x[val1], name=%N[val2]
0xF700 + 0x04
mutex_id=%x[val1], timeout=%d[val2]
0xF700 + 0x06
0xF700 + 0x07
0xF700 + 0x08
mutex_id=%x[val1], lock=%d[val2]
0xF700 + 0x09
0xF700 + 0x0A
0xF700 + 0x0B
0xF700 + 0x0C
mutex_id=%x[val1], thread_id=%x[val2]
0xF700 + 0x0D
0xF700 + 0x0E
0xF700 + 0x0F
semaphore_id=%x[val1], status=%E[val2, rtx_t:status]
0xF800 + 0x00
max_count=%d[val1], initial_count=%d[val2], attr=%x[val3]
0xF800 + 0x01
semaphore_id=%x[val1]
0xF800 + 0x03
semaphore_id=%x[val1], name=%N[val2]
0xF800 + 0x04
semaphore_id=%x[val1], timeout=%d[val2]
0xF800 + 0x06
0xF800 + 0x07
0xF800 + 0x08
semaphore_id=%x[val1], tokens=%d[val2]
0xF800 + 0x09
0xF800 + 0x0A
0xF800 + 0x0B
0xF800 + 0x0C
semaphore_id=%x[val1], count=%d[val2]
0xF800 + 0x0D
0xF800 + 0x0E
0xF800 + 0x0F
mp_id=%x[val1], status=%E[val2, rtx_t:status]
0xF900 + 0x00
block_count=%d[val1], block_size=%d[val2], attr=%x[val3]
0xF900 + 0x01
mp_id=%x[val1]
0xF900 + 0x03
mp_id=%x[val1], name=%N[val2]
0xF900 + 0x04
mp_id=%x[val1], timeout=%d[val2]
0xF900 + 0x06
0xF900 + 0x07
0xF900 + 0x08
mp_id=%x[val1], block=%x[val2]
0xF900 + 0x09
0xF900 + 0x0A
0xF900 + 0x0B
0xF900 + 0x0C
0xF900 + 0x0D
mp_id=%x[val1], capacity=%d[val2]
0xF900 + 0x0E
mp_id=%x[val1], block_size=%d[val2]
0xF900 + 0x0F
mp_id=%x[val1], count=%d[val2]
0xF900 + 0x10
mp_id=%x[val1], space=%d[val2]
0xF900 + 0x11
0xF900 + 0x12
0xF900 + 0x13
mq_id=%x[val1], status=%E[val2, rtx_t:status]
0xFA00 + 0x00
msg_count=%d[val1], msg_size=%d[val2], attr=%x[val3]
0xFA00 + 0x01
mq_id=%x[val1]
0xFA00 + 0x03
mq_id=%x[val1], name=%N[val2]
0xFA00 + 0x04
mq_id=%x[val1], msg_ptr=%x[val2], msg_prio=%d[val3], timeout=%d[val4]
0xFA00 + 0x06
mq_id=%x[val1], msg_ptr=%x[val2], timeout=%d[val3]
0xFA00 + 0x07
0xFA00 + 0x08
mq_id=%x[val1], msg_ptr=%x[val2]
0xFA00 + 0x09
0xFA00 + 0x0A
0xFA00 + 0x0B
mq_id=%x[val1], msg_ptr=%x[val2], msg_prio=%x[val3], timeout=%d[val4]
0xFA00 + 0x0C
0xFA00 + 0x0D
0xFA00 + 0x0E
0xFA00 + 0x0F
0xFA00 + 0x10
mq_id=%x[val1], capacity=%d[val2]
0xFA00 + 0x11
mq_id=%x[val1], msg_size=%d[val2]
0xFA00 + 0x12
mq_id=%x[val1], count=%d[val2]
0xFA00 + 0x13
mq_id=%x[val1], space=%d[val2]
0xFA00 + 0x14
0xFA00 + 0x15
0xFA00 + 0x16
0xFA00 + 0x17
0xFA00 + 0x18
